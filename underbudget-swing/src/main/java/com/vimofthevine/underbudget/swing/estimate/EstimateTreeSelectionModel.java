/*
 * Copyright 2012 Kyle Treubig
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.vimofthevine.underbudget.swing.estimate;

import java.util.logging.Level;
import java.util.logging.Logger;

import javax.swing.ListSelectionModel;
import javax.swing.SwingUtilities;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.tree.TreePath;
import javax.swing.tree.TreeSelectionModel;

import com.google.common.eventbus.EventBus;
import com.google.common.eventbus.Subscribe;
import com.vimofthevine.underbudget.core.estimate.Estimate;
import com.vimofthevine.underbudget.swing.estimate.events.EstimateAddedEvent;
import com.vimofthevine.underbudget.swing.estimate.events.EstimateRemovedEvent;
import com.vimofthevine.underbudget.swing.estimate.events.EstimateSelectedEvent;

/**
 * 
 * 
 * @author Kyle Treubig <kyle@vimofthevine.com>
 */
class EstimateTreeSelectionModel implements TreeSelectionListener {
	
	/**
	 * Log handle
	 */
	private static final Logger logger = Logger.getLogger(EstimateTreeSelectionModel.class.getName());
	
	/**
	 * Event bus
	 */
	private final EventBus eventBus;
	
	/**
	 * Tree selection model
	 */
	private final TreeSelectionModel selectionModel;
	
	/**
	 * The currently selected path
	 */
	private TreePath currentSelectionPath;
	
	/**
	 * Constructs a new estimate tree selection model.
	 * 
	 * @param bus       event bus
	 * @param selection tree selection model
	 */
	EstimateTreeSelectionModel(EventBus bus, TreeSelectionModel selection)
	{
		eventBus = bus;
		eventBus.register(this);
		
		selectionModel = selection;
		selectionModel.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		selectionModel.addTreeSelectionListener(this);
	}
	
	/**
	 * When the user selects an estimate in the tree
	 * (that is not currently already selected), an
	 * <code>EstimateSelectedEvent</code> is generated
	 * to alert other views of the currently selected estimate.
	 */
	@Override
	public void valueChanged(TreeSelectionEvent event)
	{
		// Don't do anything if already selected (avoid infinite loop)
		if (currentSelectionPath == null ||
			! currentSelectionPath.equals(event.getNewLeadSelectionPath()))
		{
			currentSelectionPath = event.getNewLeadSelectionPath();
			if (currentSelectionPath != null &&
				currentSelectionPath.getLastPathComponent() instanceof Estimate)
			{
				final Estimate estimate = (Estimate) currentSelectionPath.getLastPathComponent();
				
				// Get off EDT
				new Thread() {
					public void run()
					{
						eventBus.post(new EstimateSelectedEvent(estimate, currentSelectionPath));
					}
				}.start();
			}
		}
	}
	
	/**
	 * Updates the estimate tree-table to reflect the
	 * currently selected estimate. This event could
	 * have been generated by another estimate tree view.
	 * 
	 * @param event estimate selection event
	 */
	@Subscribe
	public synchronized void estimateSelected(EstimateSelectedEvent event)
	{
		logger.log(Level.FINEST, "Estimate selected: " + event);
		
		// Selection has been cleared
		if (event.getEstimate() == null)
		{
			currentSelectionPath = null;
			SwingUtilities.invokeLater(new Runnable() {
				public void run()
				{
					selectionModel.clearSelection();
				}
			});
			
			return;
		}
		
		TreePath selectionPath = (event.getTreePath() == null)
			? new EstimateTreePath(event.getEstimate()) : event.getTreePath();
		
		// Only select estimate if not already selected
		if (currentSelectionPath == null ||
			! currentSelectionPath.equals(selectionPath))
		{
			logger.log(Level.FINEST, "Selecting estimate, " + selectionPath);
			currentSelectionPath = selectionPath;
			
			// Select the new estimate
			final TreePath newSelection = selectionPath;
				
			SwingUtilities.invokeLater(new Runnable() {
				public void run()
				{
					logger.log(Level.FINEST, "Updating tree selection to selected estimate");
					selectionModel.setSelectionPath(newSelection);
				}
			});
		}
		else
		{
			logger.log(Level.FINEST, "Estimate is already selected");
		}
	}
	
	/**
	 * Updates the selection to that of a newly added estimate,
	 * if the estimate was added as a child to the currently
	 * selected estimate.
	 * 
	 * @param event estimate added event
	 */
	@Subscribe
	public synchronized void estimateAdded(EstimateAddedEvent event)
	{
		logger.log(Level.FINE, "Estimate added: " + event);
		
		final Estimate parent = event.getParent();
		final Estimate child = event.getChild();
		final TreePath childPath = new EstimateTreePath(child);
		
		// If the estimate was added to the currently selected estimate
		if (currentSelectionPath != null
			&& parent.equals(currentSelectionPath.getLastPathComponent()))
		{
			logger.log(Level.FINER, "New selection path of added estimate: " + childPath);
			
			SwingUtilities.invokeLater(new Runnable() {
				public void run()
				{
					if (selectionModel != null)
					{
						logger.log(Level.FINEST, "Updating tree selection to added estimate");
						selectionModel.setSelectionPath(childPath);
					}
				}
			});
		}
	}
	
	/**
	 * Updates the selection to that of the parent of a deleted
	 * estimate, if the deleted estimate was the currently selected
	 * estimate.
	 * 
	 * @param event estimate removed event
	 */
	@Subscribe
	public synchronized void estimateRemoved(EstimateRemovedEvent event)
	{
		logger.log(Level.FINE, "Estimate removed: " + event);
		
		final Estimate parent = event.getParent();
		final TreePath parentPath = new EstimateTreePath(parent);
		
		// If the estimate removed was the currently selected estimate
		if (parent.equals(currentSelectionPath.getParentPath()
				.getLastPathComponent()))
		{
			logger.log(Level.FINER, "New selection path of removed estimate's parent: " + parentPath);
			
			SwingUtilities.invokeLater(new Runnable() {
				public void run()
				{
					if (selectionModel != null)
					{
						logger.log(Level.FINEST, "Updating tree selection to parent of removed estimate");
						selectionModel.setSelectionPath(parentPath);
					}
				}
			});
		}
	}
	
}
